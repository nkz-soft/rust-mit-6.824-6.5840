mod args;
mod handler;
mod server;
mod task_scheduler;
mod task_service;
mod worker;
mod worker_health_check;
mod worker_service;

use crate::server::{MasterServer, Services};
use crate::task_scheduler::TaskScheduler;
use crate::worker_health_check::WorkerHealthCheck;
use clap::Parser;
use futures::{future, StreamExt};
use log::info;
use mr_common::Master;
use std::future::Future;
use std::net::{IpAddr, Ipv4Addr};
use std::sync::Arc;
use tarpc::server as tarpc_server;
use tarpc::server::incoming::Incoming;
use tarpc::server::Channel;
use tarpc::tokio_serde::formats::Json;
use tokio::sync::mpsc;
use tokio::task::AbortHandle;

async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
    tokio::spawn(fut);
}
pub async fn run() -> anyhow::Result<()> {
    let args = args::Args::parse();
    let server_addr = (IpAddr::V4(Ipv4Addr::LOCALHOST), 5555);

    let (tx, mut rx) = mpsc::channel::<u8>(32);

    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
    listener.config_mut().max_frame_length(usize::MAX);

    let state = Arc::new(Services::new(args));
    info!("Listening on port {}", listener.local_addr().port());

    let mut server_tasks = Vec::<AbortHandle>::with_capacity(3);

    server_tasks.push(WorkerHealthCheck::start(state.clone()).abort_handle());
    server_tasks.push(TaskScheduler::start(state.clone(), tx.clone()).abort_handle());
    server_tasks.push(
        tokio::spawn(async move {
            listener
                // Ignore accept errors.
                .filter_map(|r| future::ready(r.ok()))
                .map(tarpc_server::BaseChannel::with_defaults)
                // Limit channels to 5 per IP.
                .max_channels_per_key(5, |t| t.transport().peer_addr().unwrap().ip())
                // serve is generated by the service attribute. It takes as input any type implementing
                // the generated Master trait.
                .map(move |channel| {
                    let server = MasterServer::new(state.clone());
                    channel.execute(server.serve()).for_each(spawn)
                })
                // Max 10 channels.
                .buffer_unordered(10)
                .for_each(|_| async {})
                .await;
        })
        .abort_handle(),
    );

    while let Some(message) = rx.recv().await {
        if message == 0 {
            server_tasks
                .iter()
                .for_each(|abort_handle| abort_handle.abort());
            info!("Server is down");
            break;
        }
    }

    Ok(())
}
